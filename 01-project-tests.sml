use "01-project.sml";

val _ = print "---------- getVars ----------";
val _ : ''a expression -> ''a list = getVars;
val test1 = getVars (True: int expression) = [];
val test2 = getVars (False: int expression) = [];
val test3 = getVars (Not True: int expression) = [];
val test4 = getVars (Not (Var 1)) = [1];
val test5 = getVars (And[]: int expression) = [];
val test6 = getVars (Or[]: int expression) = [];
val test7 = getVars (Eq[]: int expression) = [];
val test8 = getVars (Eq[Var 1, Var 2, Var 3]) = [1,2,3];
val test9 = getVars (Imp(Var 1, Var 2)) = [1,2];
val test10 = getVars (Eq [Var "A", Var "B", Imp (Var "D", Not (Var "Q")), Var "D", Var "B"]) = ["A","B","D","Q"];

val _ = print "---------- eval ----------";
val _ : ''a list -> ''a expression -> bool = eval;
val test1 = eval [] True = true;
val test2 = eval [] False = false;
val test3 = eval [1] (Or [Var 1, Var 2]) = true;
val test4 = eval [2] (Or [Var 1, Var 2]) = true;
val test5 = eval [2] (And [Var 1, Var 2]) = false;
val test5 = eval [1] (And [Var 1, Var 2]) = false;
val test6 = eval [1,2] (And [Var 1, Var 2]) = true;
val test7 = eval [] (Not True) = false;
val test8 = eval [] (Not False) = true;
val test9 =  eval [2, 3] (And [True, Or [Var 1, Not (Not (Var 2))], Imp (Var 1, Var 2)]) = true;
val test10 = eval [] (Eq [Var 1, False, False, True]) = false;

val _ = print "---------- rmEmpty ----------";
val _: 'a expression -> 'a expression = rmEmpty;
val test1 = rmEmpty (True: int expression) = True;
val test2 = rmEmpty (False: int expression) = False;
val test3 = rmEmpty (Not True: int expression) = (Not True);
val test4 = rmEmpty (Not (Var 1)) = (Not (Var 1));
val test5 = rmEmpty (And[]: int expression) = True;
val test6 = rmEmpty (Or[]: int expression) = False;
val test7 = rmEmpty (Eq[]: int expression) = True;
val test8 = rmEmpty (Or [And [Or [Eq [Not (Var 0)]]], True]) = Or[True, True];

val _ = print "---------- beautify ----------";
val _: 'a expression -> 'a expr = beautify;
val test1 = beautify (True: int expression) = T;
val test2 = beautify (False: int expression) = F;
val test4 = beautify (Not (Var 1)) =  !!(V 1);
val test5 = beautify (Var 1) = V 1;
val test6 = beautify (And[Var 1, Var 2, Var 3]) = V 1 /\ V 2 /\ V 3;
val test7 = beautify (Or[Var 1, Var 2, Var 3]) =  V 1 \/ V 2 \/ V 3;
val test8 = beautify (Eq[Var 1, Var 2, Var 3]) = (V 1 <=> V 2) /\ (V 2 <=> V 3);
val test8 = beautify (Imp(Var 1, Var 2)) = V 1 ==> V 2;
val test9 = beautify (Or [Var "C", Eq [Var "A", Var "B", And [False, Or [Var "B", Not (Var "A")], Imp (Var "B", Var "D")]]]) = V "C" \/ (V "A" <=> V "B") /\ (V "B" <=> F /\ (V "B" \/ !! (V "A")) /\ (V "B" ==> V "D"));

val _ = print "---------- pushNegations ----------";
val _: 'a expression -> 'a expression = pushNegations;
val test1 = pushNegations (True: int expression) = True;
val test2 = pushNegations (False: int expression) = False;
val test3 = pushNegations (Not True: int expression) = (Not True);
val test4 = pushNegations (Not (Var 1)) = (Not (Var 1));
val test5 = pushNegations (Not (Not (Var 1))) = Var 1;
val test6 = pushNegations (Not (Imp (Var 1, Var 2))) = And [Var 1, Not (Var 2)];
val test7 = pushNegations (And[]: int expression) = True;
val test8 = pushNegations (Or[]: int expression) = False;
val test9 = pushNegations (Eq[]: int expression) = True;
val test10 = pushNegations (Not(And[Or[Var "A", Not(Not False), True], And [Var "B", Not (Var "C"), True]])) = Or[And [Not (Var "A"), Not False, Not True], Or [Not (Var "B"), Var "C", Not True]];

val _ = print "---------- rmConstants ----------";
val _: ''a expression -> ''a expression = rmConstants;
val test1 = rmConstants (True: int expression) = True;
val test2 = rmConstants (False: int expression) = False;
val test3 = rmConstants (Not True: int expression) = False;
val test4 = rmConstants (Not False: int expression) = True;
val test5 = rmConstants (Var 1) = Var 1;
val test6 = rmConstants (Not (Var 1)) = (Not (Var 1));
val test7 = rmConstants (Not (Imp (True, False)): int expression) = True;
val test8 = rmConstants (And[]: int expression) = True;
val test9 = rmConstants (Or[]: int expression) = False;
val test10 = rmConstants (Eq[]: int expression) = True;
val test11 = rmConstants (Not(And[Or[Var "A", Not(Not False), True], And [Var "B", Not (Var "C"), True]])) = Not (And [Var "B",Not (Var "C")]);

val _ = print "---------- rmVars ----------";
val _ : ''a expression -> ''a expression = rmVars;
val test1 = rmVars (True: int expression) = True;
val test2 = rmVars (False: int expression) = False;
val test3 = rmVars (Not True: int expression) = False;
val test4 = rmVars (Not False: int expression) = True;
val test5 = rmVars (Var 1) = Var 1;
val test6 = rmVars (Not (Var 1): int expression) = (Not (Var 1));
val test7 = rmVars (Not (Imp (True, False)): int expression) = Not (Imp (True,False));
val test8 = rmVars (And[]: int expression) = True;
val test9 = rmVars (Or[]: int expression) = False;
val test10 = rmVars (Eq[]: int expression) = True;
val test11 = rmVars (Not(And[Or[Var "A", Not(Not False), True], And [Var "B", Not (Var "C"), True]])) =  Not (And [Or [Var "A",Not True,True],And [Var "B",Not (Var "C"),True]]);
val test12 = rmVars (And [Var "A", Var "A", Var "A", Var "A", Var "A", Var "A"]) = Var "A";
val test13 = rmVars (Or [Var "A", Var "A", Var "A", Var "A", Var "A", Var "A"]) = Var "A";
val test14 = rmVars (And [Var "B", Var "A", Var "A", Var "A", Var "A", Var "A"]) = And [Var "B",Var "A"];
val test15 = rmVars (Or [Var "B", Var "A", Var "A", Var "A", Var "A", Var "A"]) = Or [Var "B",Var "A"];
val test16 = rmVars (Eq [Var "B", Var "A", Var "A", Var "A", Var "A", Var "A"]) = Eq [Var "B",Var "A"];
val test17 = rmVars (Imp (Var "A", Var "A")) = True

val _ = print "---------- simplify ----------";
val _ : ''a expression -> ''a expression = simplify;
val test1 = simplify (True: int expression) = True;
val test2 = simplify (False: int expression) = False;
val test3 = simplify (Not True: int expression) = False;
val test4 = simplify (Not False: int expression) = True;
val test5 = simplify (And[]: int expression) = True;
val test6 = simplify (Or[]: int expression) = False;
val test7 = simplify (Eq[]: int expression) = True;
val test8 = simplify (Var 1) = Var 1;
val test9 = simplify (Not (Var 1)) = (Not (Var 1));
val test10 = simplify (Not (Imp (True, False)): int expression) = True;
val test11 = simplify (And [True, Or [True, Var 3, And [And [], Or [Var 1, Not (Eq [Var 4, Or[], Eq[]])], Imp (And[], Var 2)]], True, Eq [Not (Var 3), Var 2]]) = Eq [Not (Var 3),Var 2];

val _ = print "---------- prTestEq ----------";
val _ : int -> ''a expression -> ''a expression -> bool = prTestEq;
val exp1 = Or[And [Not (Var "A"), Not False, Not True], Or [Not (Var "B"), Var "C", Not True]];
val exp2 = Or[Var "A", Not (Var "B")];
val exp3 = And[Var "C", Not (Var "B")];
val exp4 = Eq[Var "C", Not (Var "B"), Var "D"];
val test1 = List.tabulate (10, (fn i => (i, prTestEq i exp1 exp2))) = [(0,false),(1,true),(2,true),(3,false),(4,true),(5,true),(6,true),(7,true), (8,false),(9,true)];
val test2 = List.tabulate (10, (fn i => (i, prTestEq i exp1 exp3))) = [(0,false),(1,false),(2,true),(3,true),(4,true),(5,true),(6,false),(7,false),(8,false),(9,false)];
val test3 = List.tabulate (10, (fn i => (i, prTestEq i exp1 exp4))) = [(0,false),(1,false),(2,true),(3,true),(4,false),(5,false),(6,false),(7,false),(8,false),(9,false)];

val _ = print "---------- isCNF ----------";
val _: ''a expression -> bool = isCNF; 
val test1 = isCNF True = true;
val test2 = isCNF False = true;
val test3 = isCNF (Var 1) = true;
val test5 = isCNF (Not (Var 1)) = true;
val test6 = isCNF (And [Or[Var 1, Var 2], Or [Not(Var 1), Var 3]]) = true;
val test7 = isCNF (Not(And [Or[Var 1, Var 2], Or [Not(Var 1), Var 3]])) = false;
val test8 = isCNF (Or [And [Var 1, Var 2], And [Not(Var 1), Var 3]]) = false;
val test9 = isCNF (Or [Or [Var 1, Var 2], Or [Not(Var 1), Var 3]]) = false;
val test10 = isCNF (And[]) = true;
val test11 = isCNF (And[Or [], Or[]]) = true;
val test12 = isCNF (Or[Or [], Or[]]) = false;

val _ = print "---------- toWolframLang ----------";
val _: ('a -> string) -> 'a expression -> string = toWolframLang;
val test1 = toWolframLang Int.toString True = "True";
val test2 = toWolframLang Int.toString False = "False";
val test3 = toWolframLang Int.toString (Var 1) = "Var[\"1\"]";
val test4 = toWolframLang Int.toString (Not (Var 1)) = "Not[Var[\"1\"]]";
val test5 = toWolframLang Int.toString (And [Or[Var 1, Var 2], Or [Not(Var 1), Var 3]]) = "And[Or[Var[\"1\"], Var[\"2\"]], Or[Not[Var[\"1\"]], Var[\"3\"]]]";
val test6 = toWolframLang Int.toString (Not(And [Or[Var 1, Var 2], Or [Not(Var 1), Var 3]])) = "Not[And[Or[Var[\"1\"], Var[\"2\"]], Or[Not[Var[\"1\"]], Var[\"3\"]]]]";
val test7 = toWolframLang Int.toString (Or [And [Var 1, Var 2], And [Not(Var 1), Var 3]]) = "Or[And[Var[\"1\"], Var[\"2\"]], And[Not[Var[\"1\"]], Var[\"3\"]]]";
val test8 = toWolframLang Int.toString (Or [Or [Var 1, Var 2], Or [Not(Var 1), Var 3]]) = "Or[Or[Var[\"1\"], Var[\"2\"]], Or[Not[Var[\"1\"]], Var[\"3\"]]]";
val test9 = toWolframLang Int.toString (And[]) = "And[]";
val test10 = toWolframLang Int.toString (And[Or [], Or[]]) = "And[Or[], Or[]]";
val test11 = toWolframLang Int.toString (Or[Or [], Or[]]) = "Or[Or[], Or[]]";
val test12 = toWolframLang Int.toString (And [True, Or [True, Var 3, And [And [], Or [Var 1, Not (Eq [Var 4, Or[], Eq[]])], Imp (And[], Var 2)]], True, Eq [Not (Var 3), Var 2]]) = "And[True, Or[True, Var[\"3\"], And[And[], Or[Var[\"1\"], Not[Equivalent[Var[\"4\"], Or[], Equivalent[]]]], Implies[And[], Var[\"2\"]]]], True, Equivalent[Not[Var[\"3\"]], Var[\"2\"]]]";

val _ = print "---------- satSolver ----------";
val _: ''a expression -> ''a list option = satSolver;
val exp = And[Var "a", Or[Var "d", Var "c"], Or [Var "a", Var "b", Var "e"], Var "b", Not (Var "c"), Or [Var "a", Var "f", Var "g"], Or [Var "h", Var "i", Not (Var "d")]];
val test1 = satSolver (True : int expression) = SOME [];
val test2 = satSolver (False : int expression) = NONE;
val test3 = satSolver (And [] : int expression) = SOME [];
val test4 = satSolver (And [Or []] : int expression) = NONE;
val test5 = satSolver (And [Or [Var 1]]) = SOME [1];
val test6 = satSolver (And [Or [Var 1]]) = SOME [1];
val test7 = satSolver exp = SOME ["a","b","d","h"];

val _ = print "---------- bruteforce ----------";
val exp0 = And[Var "a", Or[Var "d", Var "c"], Or [Var "a", Var "b", Var "e"], Var "b", Not (Var "c"), Or [Var "a", Var "f", Var "g"], Or [Var "h", Var "i", Not (Var "d")]];
val exp1 = Or[And [Not (Var "A"), Not False, Not True], Or [Not (Var "B"), Var "C", Not True]];
val exp2 = Or[Var "A", Not (Var "B")];
val exp3 = And[Var "C", Not (Var "B")];
val exp4 = Eq[Var "C", Not (Var "B")];
val test1 = bruteforce (True : int expression) = SOME [];
val test2 = bruteforce (False : int expression) = NONE;
val test3 = bruteforce (Or [] : int expression) = NONE;
val test4 = bruteforce exp0 = NONE;
val test5 = bruteforce exp1 = SOME ["B","C"];
val test6 = bruteforce exp2 = SOME ["A"];
val test7 = bruteforce exp3 = SOME ["C"];
